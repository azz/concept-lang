-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParGrammar where
import AbsGrammar
import LexGrammar
import ErrM

}

%name pGlobal Global
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '.' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  '::' { PT _ (TS _ 10) }
  '<' { PT _ (TS _ 11) }
  '<<' { PT _ (TS _ 12) }
  '=' { PT _ (TS _ 13) }
  '=>' { PT _ (TS _ 14) }
  '>' { PT _ (TS _ 15) }
  '>>' { PT _ (TS _ 16) }
  'fn' { PT _ (TS _ 17) }
  'functor' { PT _ (TS _ 18) }
  'generic' { PT _ (TS _ 19) }
  'main' { PT _ (TS _ 20) }
  'namespace' { PT _ (TS _ 21) }
  'requires' { PT _ (TS _ 22) }
  'satisfies' { PT _ (TS _ 23) }
  '|' { PT _ (TS _ 24) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_GenericParameter { PT _ (T_GenericParameter $$) }
L_UpperIdent { PT _ (T_UpperIdent $$) }
L_LowerIdent { PT _ (T_LowerIdent $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
String  :: { String }  : L_quoted {  $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
GenericParameter    :: { GenericParameter} : L_GenericParameter { GenericParameter ($1)}
UpperIdent    :: { UpperIdent} : L_UpperIdent { UpperIdent ($1)}
LowerIdent    :: { LowerIdent} : L_LowerIdent { LowerIdent ($1)}

Global :: { Global }
Global : ListTopLevelBlock { AbsGrammar.TopLevel (reverse $1) }
ListTopLevelBlock :: { [TopLevelBlock] }
ListTopLevelBlock : {- empty -} { [] }
                  | ListTopLevelBlock TopLevelBlock { flip (:) $1 $2 }
TopLevelBlock :: { TopLevelBlock }
TopLevelBlock : Block { AbsGrammar.BlockAtTop $1 }
              | '(' 'main' FnDecl ')' { AbsGrammar.Main $3 }
ListBlock :: { [Block] }
ListBlock : {- empty -} { [] } | ListBlock Block { flip (:) $1 $2 }
NamespaceIdent :: { NamespaceIdent }
NamespaceIdent : UpperIdent { AbsGrammar.NamespaceIdentUpperIdent $1 }
               | LowerIdent { AbsGrammar.NamespaceIdentLowerIdent $1 }
ParamIdent :: { ParamIdent }
ParamIdent : UpperIdent { AbsGrammar.ParamIdentUpperIdent $1 }
           | LowerIdent { AbsGrammar.ParamIdentLowerIdent $1 }
ListNamespaceIdent :: { [NamespaceIdent] }
ListNamespaceIdent : NamespaceIdent { (:[]) $1 }
                   | NamespaceIdent '::' ListNamespaceIdent { (:) $1 $3 }
ListGenericParameter :: { [GenericParameter] }
ListGenericParameter : GenericParameter { (:[]) $1 }
                     | GenericParameter ListGenericParameter { (:) $1 $2 }
Type :: { Type }
Type : GenericParameter { AbsGrammar.GenericPlaceholder $1 }
     | UpperIdent { AbsGrammar.BaseType $1 }
     | UpperIdent ParametricType { AbsGrammar.GenericType $1 $2 }
ParametricType :: { ParametricType }
ParametricType : '<' Type '>' { AbsGrammar.Parameter $2 }
ListType :: { [Type] }
ListType : Type { (:[]) $1 } | Type ',' ListType { (:) $1 $3 }
Block :: { Block }
Block : '(' ')' { AbsGrammar.NoOp }
      | '(' 'namespace' ListNamespaceIdent ListBlock ')' { AbsGrammar.Namespace $3 (reverse $4) }
      | '(' 'functor' LowerIdent ListFunctorDecl ')' { AbsGrammar.Functor $3 $4 }
ListFunctorDecl :: { [FunctorDecl] }
ListFunctorDecl : FunctorDecl { (:[]) $1 }
                | FunctorDecl ListFunctorDecl { (:) $1 $2 }
FunctorDecl :: { FunctorDecl }
FunctorDecl : '(' FunctorSpec ')' { AbsGrammar.FunctorComponent $2 }
FunctorSpec :: { FunctorSpec }
FunctorSpec : 'generic' ListGenericParameter { AbsGrammar.Generic $2 }
            | 'satisfies' ListType { AbsGrammar.Satisfies $2 }
            | 'requires' ListType { AbsGrammar.Requires $2 }
            | 'fn' FnDecl { AbsGrammar.Fn $2 }
FnDecl :: { FnDecl }
FnDecl : '(' ListFormalArgument ')' ListStatement { AbsGrammar.FnParams $2 (reverse $4) }
ListFormalArgument :: { [FormalArgument] }
ListFormalArgument : {- empty -} { [] }
                   | FormalArgument { (:[]) $1 }
                   | FormalArgument ',' ListFormalArgument { (:) $1 $3 }
FormalArgument :: { FormalArgument }
FormalArgument : ParamIdent ':' Type { AbsGrammar.ValueParam $1 $3 }
               | ParamIdent ':' ListFormalArgument '=>' Type { AbsGrammar.GenericParam $1 $3 $5 }
InformalParam :: { InformalParam }
InformalParam : Expression { AbsGrammar.FnCallExpr $1 }
ListInformalParam :: { [InformalParam] }
ListInformalParam : {- empty -} { [] }
                  | InformalParam { (:[]) $1 }
                  | InformalParam ',' ListInformalParam { (:) $1 $3 }
ListStatement :: { [Statement] }
ListStatement : {- empty -} { [] }
              | ListStatement Statement { flip (:) $1 $2 }
Expression :: { Expression }
Expression : Expression1 { $1 }
           | ParamIdent { AbsGrammar.ValueOrRef $1 }
           | Integer { AbsGrammar.IntLiteral $1 }
           | Double { AbsGrammar.RealLiteral $1 }
           | String { AbsGrammar.StringLiteral $1 }
           | Char { AbsGrammar.CharLiteral $1 }
           | '(' 'fn' FnDecl ')' { AbsGrammar.FnLiteral $3 }
           | Expression '.' Expression { AbsGrammar.DotOperator $1 $3 }
           | Expression '|' Expression { AbsGrammar.PipeOperator $1 $3 }
           | Expression '(' ListInformalParam ')' { AbsGrammar.CallOperator $1 $3 }
           | Expression '<<' Expression { AbsGrammar.LeftShiftOperator $1 $3 }
           | Expression '>>' Expression { AbsGrammar.RightShiftOperator $1 $3 }
           | Expression '*' Expression { AbsGrammar.MultOperator $1 $3 }
           | Expression '/' Expression { AbsGrammar.DivisionOperator $1 $3 }
           | Expression '+' Expression { AbsGrammar.PlusOperator $1 $3 }
           | Expression '-' Expression { AbsGrammar.MinusOperator $1 $3 }
Expression1 :: { Expression }
Expression1 : Expression2 { $1 }
Expression2 :: { Expression }
Expression2 : Expression3 { $1 }
Expression3 :: { Expression }
Expression3 : Expression4 { $1 }
Expression4 :: { Expression }
Expression4 : Expression5 { $1 }
Expression5 :: { Expression }
Expression5 : '(' Expression ')' { $2 }
Statement :: { Statement }
Statement : FormalArgument { AbsGrammar.Declaration $1 }
          | Expression { AbsGrammar.Expr $1 }
          | Expression '=' Expression { AbsGrammar.Assignment $1 $3 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

