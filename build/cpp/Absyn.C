//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   TopLevel    ********************/
TopLevel::TopLevel(ListTopLevelBlock *p1)
{
  listtoplevelblock_ = p1;

}

TopLevel::TopLevel(const TopLevel & other)
{
  listtoplevelblock_ = other.listtoplevelblock_->clone();

}

TopLevel &TopLevel::operator=(const TopLevel & other)
{
  TopLevel tmp(other);
  swap(tmp);
  return *this;
}

void TopLevel::swap(TopLevel & other)
{
  std::swap(listtoplevelblock_, other.listtoplevelblock_);

}

TopLevel::~TopLevel()
{
  delete(listtoplevelblock_);

}

void TopLevel::accept(Visitor *v)
{
  v->visitTopLevel(this);
}

TopLevel *TopLevel::clone() const
{
  return new TopLevel(*this);
}



/********************   BlockAtTop    ********************/
BlockAtTop::BlockAtTop(Block *p1)
{
  block_ = p1;

}

BlockAtTop::BlockAtTop(const BlockAtTop & other)
{
  block_ = other.block_->clone();

}

BlockAtTop &BlockAtTop::operator=(const BlockAtTop & other)
{
  BlockAtTop tmp(other);
  swap(tmp);
  return *this;
}

void BlockAtTop::swap(BlockAtTop & other)
{
  std::swap(block_, other.block_);

}

BlockAtTop::~BlockAtTop()
{
  delete(block_);

}

void BlockAtTop::accept(Visitor *v)
{
  v->visitBlockAtTop(this);
}

BlockAtTop *BlockAtTop::clone() const
{
  return new BlockAtTop(*this);
}



/********************   Main    ********************/
Main::Main(FnDecl *p1)
{
  fndecl_ = p1;

}

Main::Main(const Main & other)
{
  fndecl_ = other.fndecl_->clone();

}

Main &Main::operator=(const Main & other)
{
  Main tmp(other);
  swap(tmp);
  return *this;
}

void Main::swap(Main & other)
{
  std::swap(fndecl_, other.fndecl_);

}

Main::~Main()
{
  delete(fndecl_);

}

void Main::accept(Visitor *v)
{
  v->visitMain(this);
}

Main *Main::clone() const
{
  return new Main(*this);
}



/********************   NamespaceIdentUpperIdent    ********************/
NamespaceIdentUpperIdent::NamespaceIdentUpperIdent(UpperIdent p1)
{
  upperident_ = p1;

}

NamespaceIdentUpperIdent::NamespaceIdentUpperIdent(const NamespaceIdentUpperIdent & other)
{
  upperident_ = other.upperident_;

}

NamespaceIdentUpperIdent &NamespaceIdentUpperIdent::operator=(const NamespaceIdentUpperIdent & other)
{
  NamespaceIdentUpperIdent tmp(other);
  swap(tmp);
  return *this;
}

void NamespaceIdentUpperIdent::swap(NamespaceIdentUpperIdent & other)
{
  std::swap(upperident_, other.upperident_);

}

NamespaceIdentUpperIdent::~NamespaceIdentUpperIdent()
{

}

void NamespaceIdentUpperIdent::accept(Visitor *v)
{
  v->visitNamespaceIdentUpperIdent(this);
}

NamespaceIdentUpperIdent *NamespaceIdentUpperIdent::clone() const
{
  return new NamespaceIdentUpperIdent(*this);
}



/********************   NamespaceIdentLowerIdent    ********************/
NamespaceIdentLowerIdent::NamespaceIdentLowerIdent(LowerIdent p1)
{
  lowerident_ = p1;

}

NamespaceIdentLowerIdent::NamespaceIdentLowerIdent(const NamespaceIdentLowerIdent & other)
{
  lowerident_ = other.lowerident_;

}

NamespaceIdentLowerIdent &NamespaceIdentLowerIdent::operator=(const NamespaceIdentLowerIdent & other)
{
  NamespaceIdentLowerIdent tmp(other);
  swap(tmp);
  return *this;
}

void NamespaceIdentLowerIdent::swap(NamespaceIdentLowerIdent & other)
{
  std::swap(lowerident_, other.lowerident_);

}

NamespaceIdentLowerIdent::~NamespaceIdentLowerIdent()
{

}

void NamespaceIdentLowerIdent::accept(Visitor *v)
{
  v->visitNamespaceIdentLowerIdent(this);
}

NamespaceIdentLowerIdent *NamespaceIdentLowerIdent::clone() const
{
  return new NamespaceIdentLowerIdent(*this);
}



/********************   ParamIdentUpperIdent    ********************/
ParamIdentUpperIdent::ParamIdentUpperIdent(UpperIdent p1)
{
  upperident_ = p1;

}

ParamIdentUpperIdent::ParamIdentUpperIdent(const ParamIdentUpperIdent & other)
{
  upperident_ = other.upperident_;

}

ParamIdentUpperIdent &ParamIdentUpperIdent::operator=(const ParamIdentUpperIdent & other)
{
  ParamIdentUpperIdent tmp(other);
  swap(tmp);
  return *this;
}

void ParamIdentUpperIdent::swap(ParamIdentUpperIdent & other)
{
  std::swap(upperident_, other.upperident_);

}

ParamIdentUpperIdent::~ParamIdentUpperIdent()
{

}

void ParamIdentUpperIdent::accept(Visitor *v)
{
  v->visitParamIdentUpperIdent(this);
}

ParamIdentUpperIdent *ParamIdentUpperIdent::clone() const
{
  return new ParamIdentUpperIdent(*this);
}



/********************   ParamIdentLowerIdent    ********************/
ParamIdentLowerIdent::ParamIdentLowerIdent(LowerIdent p1)
{
  lowerident_ = p1;

}

ParamIdentLowerIdent::ParamIdentLowerIdent(const ParamIdentLowerIdent & other)
{
  lowerident_ = other.lowerident_;

}

ParamIdentLowerIdent &ParamIdentLowerIdent::operator=(const ParamIdentLowerIdent & other)
{
  ParamIdentLowerIdent tmp(other);
  swap(tmp);
  return *this;
}

void ParamIdentLowerIdent::swap(ParamIdentLowerIdent & other)
{
  std::swap(lowerident_, other.lowerident_);

}

ParamIdentLowerIdent::~ParamIdentLowerIdent()
{

}

void ParamIdentLowerIdent::accept(Visitor *v)
{
  v->visitParamIdentLowerIdent(this);
}

ParamIdentLowerIdent *ParamIdentLowerIdent::clone() const
{
  return new ParamIdentLowerIdent(*this);
}



/********************   GenericPlaceholder    ********************/
GenericPlaceholder::GenericPlaceholder(GenericParameter p1)
{
  genericparameter_ = p1;

}

GenericPlaceholder::GenericPlaceholder(const GenericPlaceholder & other)
{
  genericparameter_ = other.genericparameter_;

}

GenericPlaceholder &GenericPlaceholder::operator=(const GenericPlaceholder & other)
{
  GenericPlaceholder tmp(other);
  swap(tmp);
  return *this;
}

void GenericPlaceholder::swap(GenericPlaceholder & other)
{
  std::swap(genericparameter_, other.genericparameter_);

}

GenericPlaceholder::~GenericPlaceholder()
{

}

void GenericPlaceholder::accept(Visitor *v)
{
  v->visitGenericPlaceholder(this);
}

GenericPlaceholder *GenericPlaceholder::clone() const
{
  return new GenericPlaceholder(*this);
}



/********************   BaseType    ********************/
BaseType::BaseType(UpperIdent p1)
{
  upperident_ = p1;

}

BaseType::BaseType(const BaseType & other)
{
  upperident_ = other.upperident_;

}

BaseType &BaseType::operator=(const BaseType & other)
{
  BaseType tmp(other);
  swap(tmp);
  return *this;
}

void BaseType::swap(BaseType & other)
{
  std::swap(upperident_, other.upperident_);

}

BaseType::~BaseType()
{

}

void BaseType::accept(Visitor *v)
{
  v->visitBaseType(this);
}

BaseType *BaseType::clone() const
{
  return new BaseType(*this);
}



/********************   GenericType    ********************/
GenericType::GenericType(UpperIdent p1, ParametricType *p2)
{
  upperident_ = p1;
  parametrictype_ = p2;

}

GenericType::GenericType(const GenericType & other)
{
  upperident_ = other.upperident_;
  parametrictype_ = other.parametrictype_->clone();

}

GenericType &GenericType::operator=(const GenericType & other)
{
  GenericType tmp(other);
  swap(tmp);
  return *this;
}

void GenericType::swap(GenericType & other)
{
  std::swap(upperident_, other.upperident_);
  std::swap(parametrictype_, other.parametrictype_);

}

GenericType::~GenericType()
{
  delete(parametrictype_);

}

void GenericType::accept(Visitor *v)
{
  v->visitGenericType(this);
}

GenericType *GenericType::clone() const
{
  return new GenericType(*this);
}



/********************   Parameter    ********************/
Parameter::Parameter(Type *p1)
{
  type_ = p1;

}

Parameter::Parameter(const Parameter & other)
{
  type_ = other.type_->clone();

}

Parameter &Parameter::operator=(const Parameter & other)
{
  Parameter tmp(other);
  swap(tmp);
  return *this;
}

void Parameter::swap(Parameter & other)
{
  std::swap(type_, other.type_);

}

Parameter::~Parameter()
{
  delete(type_);

}

void Parameter::accept(Visitor *v)
{
  v->visitParameter(this);
}

Parameter *Parameter::clone() const
{
  return new Parameter(*this);
}



/********************   NoOp    ********************/
NoOp::NoOp()
{

}

NoOp::NoOp(const NoOp & other)
{

}

NoOp &NoOp::operator=(const NoOp & other)
{
  NoOp tmp(other);
  swap(tmp);
  return *this;
}

void NoOp::swap(NoOp & other)
{

}

NoOp::~NoOp()
{

}

void NoOp::accept(Visitor *v)
{
  v->visitNoOp(this);
}

NoOp *NoOp::clone() const
{
  return new NoOp(*this);
}



/********************   Namespace    ********************/
Namespace::Namespace(ListNamespaceIdent *p1, ListBlock *p2)
{
  listnamespaceident_ = p1;
  listblock_ = p2;

}

Namespace::Namespace(const Namespace & other)
{
  listnamespaceident_ = other.listnamespaceident_->clone();
  listblock_ = other.listblock_->clone();

}

Namespace &Namespace::operator=(const Namespace & other)
{
  Namespace tmp(other);
  swap(tmp);
  return *this;
}

void Namespace::swap(Namespace & other)
{
  std::swap(listnamespaceident_, other.listnamespaceident_);
  std::swap(listblock_, other.listblock_);

}

Namespace::~Namespace()
{
  delete(listnamespaceident_);
  delete(listblock_);

}

void Namespace::accept(Visitor *v)
{
  v->visitNamespace(this);
}

Namespace *Namespace::clone() const
{
  return new Namespace(*this);
}



/********************   Functor    ********************/
Functor::Functor(LowerIdent p1, ListFunctorDecl *p2)
{
  lowerident_ = p1;
  listfunctordecl_ = p2;

}

Functor::Functor(const Functor & other)
{
  lowerident_ = other.lowerident_;
  listfunctordecl_ = other.listfunctordecl_->clone();

}

Functor &Functor::operator=(const Functor & other)
{
  Functor tmp(other);
  swap(tmp);
  return *this;
}

void Functor::swap(Functor & other)
{
  std::swap(lowerident_, other.lowerident_);
  std::swap(listfunctordecl_, other.listfunctordecl_);

}

Functor::~Functor()
{
  delete(listfunctordecl_);

}

void Functor::accept(Visitor *v)
{
  v->visitFunctor(this);
}

Functor *Functor::clone() const
{
  return new Functor(*this);
}



/********************   FunctorComponent    ********************/
FunctorComponent::FunctorComponent(FunctorSpec *p1)
{
  functorspec_ = p1;

}

FunctorComponent::FunctorComponent(const FunctorComponent & other)
{
  functorspec_ = other.functorspec_->clone();

}

FunctorComponent &FunctorComponent::operator=(const FunctorComponent & other)
{
  FunctorComponent tmp(other);
  swap(tmp);
  return *this;
}

void FunctorComponent::swap(FunctorComponent & other)
{
  std::swap(functorspec_, other.functorspec_);

}

FunctorComponent::~FunctorComponent()
{
  delete(functorspec_);

}

void FunctorComponent::accept(Visitor *v)
{
  v->visitFunctorComponent(this);
}

FunctorComponent *FunctorComponent::clone() const
{
  return new FunctorComponent(*this);
}



/********************   Generic    ********************/
Generic::Generic(ListGenericParameter *p1)
{
  listgenericparameter_ = p1;

}

Generic::Generic(const Generic & other)
{
  listgenericparameter_ = other.listgenericparameter_->clone();

}

Generic &Generic::operator=(const Generic & other)
{
  Generic tmp(other);
  swap(tmp);
  return *this;
}

void Generic::swap(Generic & other)
{
  std::swap(listgenericparameter_, other.listgenericparameter_);

}

Generic::~Generic()
{
  delete(listgenericparameter_);

}

void Generic::accept(Visitor *v)
{
  v->visitGeneric(this);
}

Generic *Generic::clone() const
{
  return new Generic(*this);
}



/********************   Satisfies    ********************/
Satisfies::Satisfies(ListType *p1)
{
  listtype_ = p1;

}

Satisfies::Satisfies(const Satisfies & other)
{
  listtype_ = other.listtype_->clone();

}

Satisfies &Satisfies::operator=(const Satisfies & other)
{
  Satisfies tmp(other);
  swap(tmp);
  return *this;
}

void Satisfies::swap(Satisfies & other)
{
  std::swap(listtype_, other.listtype_);

}

Satisfies::~Satisfies()
{
  delete(listtype_);

}

void Satisfies::accept(Visitor *v)
{
  v->visitSatisfies(this);
}

Satisfies *Satisfies::clone() const
{
  return new Satisfies(*this);
}



/********************   Requires    ********************/
Requires::Requires(ListType *p1)
{
  listtype_ = p1;

}

Requires::Requires(const Requires & other)
{
  listtype_ = other.listtype_->clone();

}

Requires &Requires::operator=(const Requires & other)
{
  Requires tmp(other);
  swap(tmp);
  return *this;
}

void Requires::swap(Requires & other)
{
  std::swap(listtype_, other.listtype_);

}

Requires::~Requires()
{
  delete(listtype_);

}

void Requires::accept(Visitor *v)
{
  v->visitRequires(this);
}

Requires *Requires::clone() const
{
  return new Requires(*this);
}



/********************   Fn    ********************/
Fn::Fn(FnDecl *p1)
{
  fndecl_ = p1;

}

Fn::Fn(const Fn & other)
{
  fndecl_ = other.fndecl_->clone();

}

Fn &Fn::operator=(const Fn & other)
{
  Fn tmp(other);
  swap(tmp);
  return *this;
}

void Fn::swap(Fn & other)
{
  std::swap(fndecl_, other.fndecl_);

}

Fn::~Fn()
{
  delete(fndecl_);

}

void Fn::accept(Visitor *v)
{
  v->visitFn(this);
}

Fn *Fn::clone() const
{
  return new Fn(*this);
}



/********************   FnParams    ********************/
FnParams::FnParams(ListFormalArgument *p1, ListStatement *p2)
{
  listformalargument_ = p1;
  liststatement_ = p2;

}

FnParams::FnParams(const FnParams & other)
{
  listformalargument_ = other.listformalargument_->clone();
  liststatement_ = other.liststatement_->clone();

}

FnParams &FnParams::operator=(const FnParams & other)
{
  FnParams tmp(other);
  swap(tmp);
  return *this;
}

void FnParams::swap(FnParams & other)
{
  std::swap(listformalargument_, other.listformalargument_);
  std::swap(liststatement_, other.liststatement_);

}

FnParams::~FnParams()
{
  delete(listformalargument_);
  delete(liststatement_);

}

void FnParams::accept(Visitor *v)
{
  v->visitFnParams(this);
}

FnParams *FnParams::clone() const
{
  return new FnParams(*this);
}



/********************   ValueParam    ********************/
ValueParam::ValueParam(ParamIdent *p1, Type *p2)
{
  paramident_ = p1;
  type_ = p2;

}

ValueParam::ValueParam(const ValueParam & other)
{
  paramident_ = other.paramident_->clone();
  type_ = other.type_->clone();

}

ValueParam &ValueParam::operator=(const ValueParam & other)
{
  ValueParam tmp(other);
  swap(tmp);
  return *this;
}

void ValueParam::swap(ValueParam & other)
{
  std::swap(paramident_, other.paramident_);
  std::swap(type_, other.type_);

}

ValueParam::~ValueParam()
{
  delete(paramident_);
  delete(type_);

}

void ValueParam::accept(Visitor *v)
{
  v->visitValueParam(this);
}

ValueParam *ValueParam::clone() const
{
  return new ValueParam(*this);
}



/********************   GenericParam    ********************/
GenericParam::GenericParam(ParamIdent *p1, ListFormalArgument *p2, Type *p3)
{
  paramident_ = p1;
  listformalargument_ = p2;
  type_ = p3;

}

GenericParam::GenericParam(const GenericParam & other)
{
  paramident_ = other.paramident_->clone();
  listformalargument_ = other.listformalargument_->clone();
  type_ = other.type_->clone();

}

GenericParam &GenericParam::operator=(const GenericParam & other)
{
  GenericParam tmp(other);
  swap(tmp);
  return *this;
}

void GenericParam::swap(GenericParam & other)
{
  std::swap(paramident_, other.paramident_);
  std::swap(listformalargument_, other.listformalargument_);
  std::swap(type_, other.type_);

}

GenericParam::~GenericParam()
{
  delete(paramident_);
  delete(listformalargument_);
  delete(type_);

}

void GenericParam::accept(Visitor *v)
{
  v->visitGenericParam(this);
}

GenericParam *GenericParam::clone() const
{
  return new GenericParam(*this);
}



/********************   FnCallExpr    ********************/
FnCallExpr::FnCallExpr(Expression *p1)
{
  expression_ = p1;

}

FnCallExpr::FnCallExpr(const FnCallExpr & other)
{
  expression_ = other.expression_->clone();

}

FnCallExpr &FnCallExpr::operator=(const FnCallExpr & other)
{
  FnCallExpr tmp(other);
  swap(tmp);
  return *this;
}

void FnCallExpr::swap(FnCallExpr & other)
{
  std::swap(expression_, other.expression_);

}

FnCallExpr::~FnCallExpr()
{
  delete(expression_);

}

void FnCallExpr::accept(Visitor *v)
{
  v->visitFnCallExpr(this);
}

FnCallExpr *FnCallExpr::clone() const
{
  return new FnCallExpr(*this);
}



/********************   ValueOrRef    ********************/
ValueOrRef::ValueOrRef(ParamIdent *p1)
{
  paramident_ = p1;

}

ValueOrRef::ValueOrRef(const ValueOrRef & other)
{
  paramident_ = other.paramident_->clone();

}

ValueOrRef &ValueOrRef::operator=(const ValueOrRef & other)
{
  ValueOrRef tmp(other);
  swap(tmp);
  return *this;
}

void ValueOrRef::swap(ValueOrRef & other)
{
  std::swap(paramident_, other.paramident_);

}

ValueOrRef::~ValueOrRef()
{
  delete(paramident_);

}

void ValueOrRef::accept(Visitor *v)
{
  v->visitValueOrRef(this);
}

ValueOrRef *ValueOrRef::clone() const
{
  return new ValueOrRef(*this);
}



/********************   IntLiteral    ********************/
IntLiteral::IntLiteral(Integer p1)
{
  integer_ = p1;

}

IntLiteral::IntLiteral(const IntLiteral & other)
{
  integer_ = other.integer_;

}

IntLiteral &IntLiteral::operator=(const IntLiteral & other)
{
  IntLiteral tmp(other);
  swap(tmp);
  return *this;
}

void IntLiteral::swap(IntLiteral & other)
{
  std::swap(integer_, other.integer_);

}

IntLiteral::~IntLiteral()
{

}

void IntLiteral::accept(Visitor *v)
{
  v->visitIntLiteral(this);
}

IntLiteral *IntLiteral::clone() const
{
  return new IntLiteral(*this);
}



/********************   RealLiteral    ********************/
RealLiteral::RealLiteral(Double p1)
{
  double_ = p1;

}

RealLiteral::RealLiteral(const RealLiteral & other)
{
  double_ = other.double_;

}

RealLiteral &RealLiteral::operator=(const RealLiteral & other)
{
  RealLiteral tmp(other);
  swap(tmp);
  return *this;
}

void RealLiteral::swap(RealLiteral & other)
{
  std::swap(double_, other.double_);

}

RealLiteral::~RealLiteral()
{

}

void RealLiteral::accept(Visitor *v)
{
  v->visitRealLiteral(this);
}

RealLiteral *RealLiteral::clone() const
{
  return new RealLiteral(*this);
}



/********************   StringLiteral    ********************/
StringLiteral::StringLiteral(String p1)
{
  string_ = p1;

}

StringLiteral::StringLiteral(const StringLiteral & other)
{
  string_ = other.string_;

}

StringLiteral &StringLiteral::operator=(const StringLiteral & other)
{
  StringLiteral tmp(other);
  swap(tmp);
  return *this;
}

void StringLiteral::swap(StringLiteral & other)
{
  std::swap(string_, other.string_);

}

StringLiteral::~StringLiteral()
{

}

void StringLiteral::accept(Visitor *v)
{
  v->visitStringLiteral(this);
}

StringLiteral *StringLiteral::clone() const
{
  return new StringLiteral(*this);
}



/********************   CharLiteral    ********************/
CharLiteral::CharLiteral(Char p1)
{
  char_ = p1;

}

CharLiteral::CharLiteral(const CharLiteral & other)
{
  char_ = other.char_;

}

CharLiteral &CharLiteral::operator=(const CharLiteral & other)
{
  CharLiteral tmp(other);
  swap(tmp);
  return *this;
}

void CharLiteral::swap(CharLiteral & other)
{
  std::swap(char_, other.char_);

}

CharLiteral::~CharLiteral()
{

}

void CharLiteral::accept(Visitor *v)
{
  v->visitCharLiteral(this);
}

CharLiteral *CharLiteral::clone() const
{
  return new CharLiteral(*this);
}



/********************   FnLiteral    ********************/
FnLiteral::FnLiteral(FnDecl *p1)
{
  fndecl_ = p1;

}

FnLiteral::FnLiteral(const FnLiteral & other)
{
  fndecl_ = other.fndecl_->clone();

}

FnLiteral &FnLiteral::operator=(const FnLiteral & other)
{
  FnLiteral tmp(other);
  swap(tmp);
  return *this;
}

void FnLiteral::swap(FnLiteral & other)
{
  std::swap(fndecl_, other.fndecl_);

}

FnLiteral::~FnLiteral()
{
  delete(fndecl_);

}

void FnLiteral::accept(Visitor *v)
{
  v->visitFnLiteral(this);
}

FnLiteral *FnLiteral::clone() const
{
  return new FnLiteral(*this);
}



/********************   DotOperator    ********************/
DotOperator::DotOperator(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

DotOperator::DotOperator(const DotOperator & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

DotOperator &DotOperator::operator=(const DotOperator & other)
{
  DotOperator tmp(other);
  swap(tmp);
  return *this;
}

void DotOperator::swap(DotOperator & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

DotOperator::~DotOperator()
{
  delete(expression_1);
  delete(expression_2);

}

void DotOperator::accept(Visitor *v)
{
  v->visitDotOperator(this);
}

DotOperator *DotOperator::clone() const
{
  return new DotOperator(*this);
}



/********************   PipeOperator    ********************/
PipeOperator::PipeOperator(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

PipeOperator::PipeOperator(const PipeOperator & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

PipeOperator &PipeOperator::operator=(const PipeOperator & other)
{
  PipeOperator tmp(other);
  swap(tmp);
  return *this;
}

void PipeOperator::swap(PipeOperator & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

PipeOperator::~PipeOperator()
{
  delete(expression_1);
  delete(expression_2);

}

void PipeOperator::accept(Visitor *v)
{
  v->visitPipeOperator(this);
}

PipeOperator *PipeOperator::clone() const
{
  return new PipeOperator(*this);
}



/********************   CallOperator    ********************/
CallOperator::CallOperator(Expression *p1, ListInformalParam *p2)
{
  expression_ = p1;
  listinformalparam_ = p2;

}

CallOperator::CallOperator(const CallOperator & other)
{
  expression_ = other.expression_->clone();
  listinformalparam_ = other.listinformalparam_->clone();

}

CallOperator &CallOperator::operator=(const CallOperator & other)
{
  CallOperator tmp(other);
  swap(tmp);
  return *this;
}

void CallOperator::swap(CallOperator & other)
{
  std::swap(expression_, other.expression_);
  std::swap(listinformalparam_, other.listinformalparam_);

}

CallOperator::~CallOperator()
{
  delete(expression_);
  delete(listinformalparam_);

}

void CallOperator::accept(Visitor *v)
{
  v->visitCallOperator(this);
}

CallOperator *CallOperator::clone() const
{
  return new CallOperator(*this);
}



/********************   LeftShiftOperator    ********************/
LeftShiftOperator::LeftShiftOperator(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

LeftShiftOperator::LeftShiftOperator(const LeftShiftOperator & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

LeftShiftOperator &LeftShiftOperator::operator=(const LeftShiftOperator & other)
{
  LeftShiftOperator tmp(other);
  swap(tmp);
  return *this;
}

void LeftShiftOperator::swap(LeftShiftOperator & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

LeftShiftOperator::~LeftShiftOperator()
{
  delete(expression_1);
  delete(expression_2);

}

void LeftShiftOperator::accept(Visitor *v)
{
  v->visitLeftShiftOperator(this);
}

LeftShiftOperator *LeftShiftOperator::clone() const
{
  return new LeftShiftOperator(*this);
}



/********************   RightShiftOperator    ********************/
RightShiftOperator::RightShiftOperator(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

RightShiftOperator::RightShiftOperator(const RightShiftOperator & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

RightShiftOperator &RightShiftOperator::operator=(const RightShiftOperator & other)
{
  RightShiftOperator tmp(other);
  swap(tmp);
  return *this;
}

void RightShiftOperator::swap(RightShiftOperator & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

RightShiftOperator::~RightShiftOperator()
{
  delete(expression_1);
  delete(expression_2);

}

void RightShiftOperator::accept(Visitor *v)
{
  v->visitRightShiftOperator(this);
}

RightShiftOperator *RightShiftOperator::clone() const
{
  return new RightShiftOperator(*this);
}



/********************   MultOperator    ********************/
MultOperator::MultOperator(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

MultOperator::MultOperator(const MultOperator & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

MultOperator &MultOperator::operator=(const MultOperator & other)
{
  MultOperator tmp(other);
  swap(tmp);
  return *this;
}

void MultOperator::swap(MultOperator & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

MultOperator::~MultOperator()
{
  delete(expression_1);
  delete(expression_2);

}

void MultOperator::accept(Visitor *v)
{
  v->visitMultOperator(this);
}

MultOperator *MultOperator::clone() const
{
  return new MultOperator(*this);
}



/********************   DivisionOperator    ********************/
DivisionOperator::DivisionOperator(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

DivisionOperator::DivisionOperator(const DivisionOperator & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

DivisionOperator &DivisionOperator::operator=(const DivisionOperator & other)
{
  DivisionOperator tmp(other);
  swap(tmp);
  return *this;
}

void DivisionOperator::swap(DivisionOperator & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

DivisionOperator::~DivisionOperator()
{
  delete(expression_1);
  delete(expression_2);

}

void DivisionOperator::accept(Visitor *v)
{
  v->visitDivisionOperator(this);
}

DivisionOperator *DivisionOperator::clone() const
{
  return new DivisionOperator(*this);
}



/********************   PlusOperator    ********************/
PlusOperator::PlusOperator(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

PlusOperator::PlusOperator(const PlusOperator & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

PlusOperator &PlusOperator::operator=(const PlusOperator & other)
{
  PlusOperator tmp(other);
  swap(tmp);
  return *this;
}

void PlusOperator::swap(PlusOperator & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

PlusOperator::~PlusOperator()
{
  delete(expression_1);
  delete(expression_2);

}

void PlusOperator::accept(Visitor *v)
{
  v->visitPlusOperator(this);
}

PlusOperator *PlusOperator::clone() const
{
  return new PlusOperator(*this);
}



/********************   MinusOperator    ********************/
MinusOperator::MinusOperator(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

MinusOperator::MinusOperator(const MinusOperator & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

MinusOperator &MinusOperator::operator=(const MinusOperator & other)
{
  MinusOperator tmp(other);
  swap(tmp);
  return *this;
}

void MinusOperator::swap(MinusOperator & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

MinusOperator::~MinusOperator()
{
  delete(expression_1);
  delete(expression_2);

}

void MinusOperator::accept(Visitor *v)
{
  v->visitMinusOperator(this);
}

MinusOperator *MinusOperator::clone() const
{
  return new MinusOperator(*this);
}



/********************   Declaration    ********************/
Declaration::Declaration(FormalArgument *p1)
{
  formalargument_ = p1;

}

Declaration::Declaration(const Declaration & other)
{
  formalargument_ = other.formalargument_->clone();

}

Declaration &Declaration::operator=(const Declaration & other)
{
  Declaration tmp(other);
  swap(tmp);
  return *this;
}

void Declaration::swap(Declaration & other)
{
  std::swap(formalargument_, other.formalargument_);

}

Declaration::~Declaration()
{
  delete(formalargument_);

}

void Declaration::accept(Visitor *v)
{
  v->visitDeclaration(this);
}

Declaration *Declaration::clone() const
{
  return new Declaration(*this);
}



/********************   Expr    ********************/
Expr::Expr(Expression *p1)
{
  expression_ = p1;

}

Expr::Expr(const Expr & other)
{
  expression_ = other.expression_->clone();

}

Expr &Expr::operator=(const Expr & other)
{
  Expr tmp(other);
  swap(tmp);
  return *this;
}

void Expr::swap(Expr & other)
{
  std::swap(expression_, other.expression_);

}

Expr::~Expr()
{
  delete(expression_);

}

void Expr::accept(Visitor *v)
{
  v->visitExpr(this);
}

Expr *Expr::clone() const
{
  return new Expr(*this);
}



/********************   Assignment    ********************/
Assignment::Assignment(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

Assignment::Assignment(const Assignment & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

Assignment &Assignment::operator=(const Assignment & other)
{
  Assignment tmp(other);
  swap(tmp);
  return *this;
}

void Assignment::swap(Assignment & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

Assignment::~Assignment()
{
  delete(expression_1);
  delete(expression_2);

}

void Assignment::accept(Visitor *v)
{
  v->visitAssignment(this);
}

Assignment *Assignment::clone() const
{
  return new Assignment(*this);
}




/********************   ListTopLevelBlock    ********************/

void ListTopLevelBlock::accept(Visitor *v)
{
  v->visitListTopLevelBlock(this);
}


ListTopLevelBlock *ListTopLevelBlock::clone() const
{
  return new ListTopLevelBlock(*this);
}


/********************   ListBlock    ********************/

void ListBlock::accept(Visitor *v)
{
  v->visitListBlock(this);
}


ListBlock *ListBlock::clone() const
{
  return new ListBlock(*this);
}


/********************   ListNamespaceIdent    ********************/

void ListNamespaceIdent::accept(Visitor *v)
{
  v->visitListNamespaceIdent(this);
}


ListNamespaceIdent *ListNamespaceIdent::clone() const
{
  return new ListNamespaceIdent(*this);
}


/********************   ListGenericParameter    ********************/

void ListGenericParameter::accept(Visitor *v)
{
  v->visitListGenericParameter(this);
}


ListGenericParameter *ListGenericParameter::clone() const
{
  return new ListGenericParameter(*this);
}


/********************   ListType    ********************/

void ListType::accept(Visitor *v)
{
  v->visitListType(this);
}


ListType *ListType::clone() const
{
  return new ListType(*this);
}


/********************   ListFunctorDecl    ********************/

void ListFunctorDecl::accept(Visitor *v)
{
  v->visitListFunctorDecl(this);
}


ListFunctorDecl *ListFunctorDecl::clone() const
{
  return new ListFunctorDecl(*this);
}


/********************   ListFormalArgument    ********************/

void ListFormalArgument::accept(Visitor *v)
{
  v->visitListFormalArgument(this);
}


ListFormalArgument *ListFormalArgument::clone() const
{
  return new ListFormalArgument(*this);
}


/********************   ListInformalParam    ********************/

void ListInformalParam::accept(Visitor *v)
{
  v->visitListInformalParam(this);
}


ListInformalParam *ListInformalParam::clone() const
{
  return new ListInformalParam(*this);
}


/********************   ListStatement    ********************/

void ListStatement::accept(Visitor *v)
{
  v->visitListStatement(this);
}


ListStatement *ListStatement::clone() const
{
  return new ListStatement(*this);
}




