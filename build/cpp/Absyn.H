#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string GenericParameter;
typedef std::string UpperIdent;
typedef std::string LowerIdent;


/********************   Forward Declarations    ********************/

class Global;
class TopLevelBlock;
class NamespaceIdent;
class ParamIdent;
class Type;
class ParametricType;
class Block;
class FunctorDecl;
class FunctorSpec;
class FnDecl;
class FormalArgument;
class InformalParam;
class Expression;
class Statement;
class TopLevel;
class BlockAtTop;
class NamespaceIdentUpperIdent;
class NamespaceIdentLowerIdent;
class ParamIdentUpperIdent;
class ParamIdentLowerIdent;
class GenericPlaceholder;
class BaseType;
class GenericType;
class Parameter;
class NoOp;
class Main;
class Namespace;
class Functor;
class FunctorComponent;
class Generic;
class Satisfies;
class Requires;
class Fn;
class FnParams;
class ValueParam;
class GenericParam;
class FnCallExpr;
class Declaration;
class Expr;
class Assignment;
class ValueOrRef;
class IntLiteral;
class RealLiteral;
class StringLiteral;
class CharLiteral;
class FnLiteral;
class DotOperator;
class PipeOperator;
class CallOperator;
class LeftShiftOperator;
class RightShiftOperator;
class MultOperator;
class DivisionOperator;
class PlusOperator;
class MinusOperator;
class ListTopLevelBlock;
class ListBlock;
class ListNamespaceIdent;
class ListGenericParameter;
class ListType;
class ListFunctorDecl;
class ListFormalArgument;
class ListInformalParam;
class ListStatement;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitGlobal(Global *p) = 0;
  virtual void visitTopLevelBlock(TopLevelBlock *p) = 0;
  virtual void visitNamespaceIdent(NamespaceIdent *p) = 0;
  virtual void visitParamIdent(ParamIdent *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitParametricType(ParametricType *p) = 0;
  virtual void visitBlock(Block *p) = 0;
  virtual void visitFunctorDecl(FunctorDecl *p) = 0;
  virtual void visitFunctorSpec(FunctorSpec *p) = 0;
  virtual void visitFnDecl(FnDecl *p) = 0;
  virtual void visitFormalArgument(FormalArgument *p) = 0;
  virtual void visitInformalParam(InformalParam *p) = 0;
  virtual void visitExpression(Expression *p) = 0;
  virtual void visitStatement(Statement *p) = 0;
  virtual void visitTopLevel(TopLevel *p) = 0;
  virtual void visitBlockAtTop(BlockAtTop *p) = 0;
  virtual void visitNamespaceIdentUpperIdent(NamespaceIdentUpperIdent *p) = 0;
  virtual void visitNamespaceIdentLowerIdent(NamespaceIdentLowerIdent *p) = 0;
  virtual void visitParamIdentUpperIdent(ParamIdentUpperIdent *p) = 0;
  virtual void visitParamIdentLowerIdent(ParamIdentLowerIdent *p) = 0;
  virtual void visitGenericPlaceholder(GenericPlaceholder *p) = 0;
  virtual void visitBaseType(BaseType *p) = 0;
  virtual void visitGenericType(GenericType *p) = 0;
  virtual void visitParameter(Parameter *p) = 0;
  virtual void visitNoOp(NoOp *p) = 0;
  virtual void visitMain(Main *p) = 0;
  virtual void visitNamespace(Namespace *p) = 0;
  virtual void visitFunctor(Functor *p) = 0;
  virtual void visitFunctorComponent(FunctorComponent *p) = 0;
  virtual void visitGeneric(Generic *p) = 0;
  virtual void visitSatisfies(Satisfies *p) = 0;
  virtual void visitRequires(Requires *p) = 0;
  virtual void visitFn(Fn *p) = 0;
  virtual void visitFnParams(FnParams *p) = 0;
  virtual void visitValueParam(ValueParam *p) = 0;
  virtual void visitGenericParam(GenericParam *p) = 0;
  virtual void visitFnCallExpr(FnCallExpr *p) = 0;
  virtual void visitDeclaration(Declaration *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitAssignment(Assignment *p) = 0;
  virtual void visitValueOrRef(ValueOrRef *p) = 0;
  virtual void visitIntLiteral(IntLiteral *p) = 0;
  virtual void visitRealLiteral(RealLiteral *p) = 0;
  virtual void visitStringLiteral(StringLiteral *p) = 0;
  virtual void visitCharLiteral(CharLiteral *p) = 0;
  virtual void visitFnLiteral(FnLiteral *p) = 0;
  virtual void visitDotOperator(DotOperator *p) = 0;
  virtual void visitPipeOperator(PipeOperator *p) = 0;
  virtual void visitCallOperator(CallOperator *p) = 0;
  virtual void visitLeftShiftOperator(LeftShiftOperator *p) = 0;
  virtual void visitRightShiftOperator(RightShiftOperator *p) = 0;
  virtual void visitMultOperator(MultOperator *p) = 0;
  virtual void visitDivisionOperator(DivisionOperator *p) = 0;
  virtual void visitPlusOperator(PlusOperator *p) = 0;
  virtual void visitMinusOperator(MinusOperator *p) = 0;
  virtual void visitListTopLevelBlock(ListTopLevelBlock *p) = 0;
  virtual void visitListBlock(ListBlock *p) = 0;
  virtual void visitListNamespaceIdent(ListNamespaceIdent *p) = 0;
  virtual void visitListGenericParameter(ListGenericParameter *p) = 0;
  virtual void visitListType(ListType *p) = 0;
  virtual void visitListFunctorDecl(ListFunctorDecl *p) = 0;
  virtual void visitListFormalArgument(ListFormalArgument *p) = 0;
  virtual void visitListInformalParam(ListInformalParam *p) = 0;
  virtual void visitListStatement(ListStatement *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitGenericParameter(GenericParameter x) = 0;
  virtual void visitUpperIdent(UpperIdent x) = 0;
  virtual void visitLowerIdent(LowerIdent x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Global : public Visitable
{
public:
  virtual Global *clone() const = 0;

};

class TopLevelBlock : public Visitable
{
public:
  virtual TopLevelBlock *clone() const = 0;

};

class NamespaceIdent : public Visitable
{
public:
  virtual NamespaceIdent *clone() const = 0;

};

class ParamIdent : public Visitable
{
public:
  virtual ParamIdent *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};

class ParametricType : public Visitable
{
public:
  virtual ParametricType *clone() const = 0;

};

class Block : public Visitable
{
public:
  virtual Block *clone() const = 0;

};

class FunctorDecl : public Visitable
{
public:
  virtual FunctorDecl *clone() const = 0;

};

class FunctorSpec : public Visitable
{
public:
  virtual FunctorSpec *clone() const = 0;

};

class FnDecl : public Visitable
{
public:
  virtual FnDecl *clone() const = 0;

};

class FormalArgument : public Visitable
{
public:
  virtual FormalArgument *clone() const = 0;

};

class InformalParam : public Visitable
{
public:
  virtual InformalParam *clone() const = 0;

};

class Expression : public Visitable
{
public:
  virtual Expression *clone() const = 0;

};

class Statement : public Visitable
{
public:
  virtual Statement *clone() const = 0;

};



class TopLevel : public Global
{
public:
  ListTopLevelBlock *listtoplevelblock_;

  TopLevel(const TopLevel &);
  TopLevel &operator=(const TopLevel &);
  TopLevel(ListTopLevelBlock *p1);
  ~TopLevel();
  virtual void accept(Visitor *v);
  virtual TopLevel *clone() const;
  void swap(TopLevel &);
};

class BlockAtTop : public TopLevelBlock
{
public:
  Block *block_;

  BlockAtTop(const BlockAtTop &);
  BlockAtTop &operator=(const BlockAtTop &);
  BlockAtTop(Block *p1);
  ~BlockAtTop();
  virtual void accept(Visitor *v);
  virtual BlockAtTop *clone() const;
  void swap(BlockAtTop &);
};

class Main : public TopLevelBlock
{
public:
  FnDecl *fndecl_;

  Main(const Main &);
  Main &operator=(const Main &);
  Main(FnDecl *p1);
  ~Main();
  virtual void accept(Visitor *v);
  virtual Main *clone() const;
  void swap(Main &);
};

class NamespaceIdentUpperIdent : public NamespaceIdent
{
public:
  UpperIdent upperident_;

  NamespaceIdentUpperIdent(const NamespaceIdentUpperIdent &);
  NamespaceIdentUpperIdent &operator=(const NamespaceIdentUpperIdent &);
  NamespaceIdentUpperIdent(UpperIdent p1);
  ~NamespaceIdentUpperIdent();
  virtual void accept(Visitor *v);
  virtual NamespaceIdentUpperIdent *clone() const;
  void swap(NamespaceIdentUpperIdent &);
};

class NamespaceIdentLowerIdent : public NamespaceIdent
{
public:
  LowerIdent lowerident_;

  NamespaceIdentLowerIdent(const NamespaceIdentLowerIdent &);
  NamespaceIdentLowerIdent &operator=(const NamespaceIdentLowerIdent &);
  NamespaceIdentLowerIdent(LowerIdent p1);
  ~NamespaceIdentLowerIdent();
  virtual void accept(Visitor *v);
  virtual NamespaceIdentLowerIdent *clone() const;
  void swap(NamespaceIdentLowerIdent &);
};

class ParamIdentUpperIdent : public ParamIdent
{
public:
  UpperIdent upperident_;

  ParamIdentUpperIdent(const ParamIdentUpperIdent &);
  ParamIdentUpperIdent &operator=(const ParamIdentUpperIdent &);
  ParamIdentUpperIdent(UpperIdent p1);
  ~ParamIdentUpperIdent();
  virtual void accept(Visitor *v);
  virtual ParamIdentUpperIdent *clone() const;
  void swap(ParamIdentUpperIdent &);
};

class ParamIdentLowerIdent : public ParamIdent
{
public:
  LowerIdent lowerident_;

  ParamIdentLowerIdent(const ParamIdentLowerIdent &);
  ParamIdentLowerIdent &operator=(const ParamIdentLowerIdent &);
  ParamIdentLowerIdent(LowerIdent p1);
  ~ParamIdentLowerIdent();
  virtual void accept(Visitor *v);
  virtual ParamIdentLowerIdent *clone() const;
  void swap(ParamIdentLowerIdent &);
};

class GenericPlaceholder : public Type
{
public:
  GenericParameter genericparameter_;

  GenericPlaceholder(const GenericPlaceholder &);
  GenericPlaceholder &operator=(const GenericPlaceholder &);
  GenericPlaceholder(GenericParameter p1);
  ~GenericPlaceholder();
  virtual void accept(Visitor *v);
  virtual GenericPlaceholder *clone() const;
  void swap(GenericPlaceholder &);
};

class BaseType : public Type
{
public:
  UpperIdent upperident_;

  BaseType(const BaseType &);
  BaseType &operator=(const BaseType &);
  BaseType(UpperIdent p1);
  ~BaseType();
  virtual void accept(Visitor *v);
  virtual BaseType *clone() const;
  void swap(BaseType &);
};

class GenericType : public Type
{
public:
  UpperIdent upperident_;
  ParametricType *parametrictype_;

  GenericType(const GenericType &);
  GenericType &operator=(const GenericType &);
  GenericType(UpperIdent p1, ParametricType *p2);
  ~GenericType();
  virtual void accept(Visitor *v);
  virtual GenericType *clone() const;
  void swap(GenericType &);
};

class Parameter : public ParametricType
{
public:
  Type *type_;

  Parameter(const Parameter &);
  Parameter &operator=(const Parameter &);
  Parameter(Type *p1);
  ~Parameter();
  virtual void accept(Visitor *v);
  virtual Parameter *clone() const;
  void swap(Parameter &);
};

class NoOp : public Block
{
public:

  NoOp(const NoOp &);
  NoOp &operator=(const NoOp &);
  NoOp();
  ~NoOp();
  virtual void accept(Visitor *v);
  virtual NoOp *clone() const;
  void swap(NoOp &);
};

class Namespace : public Block
{
public:
  ListNamespaceIdent *listnamespaceident_;
  ListBlock *listblock_;

  Namespace(const Namespace &);
  Namespace &operator=(const Namespace &);
  Namespace(ListNamespaceIdent *p1, ListBlock *p2);
  ~Namespace();
  virtual void accept(Visitor *v);
  virtual Namespace *clone() const;
  void swap(Namespace &);
};

class Functor : public Block
{
public:
  LowerIdent lowerident_;
  ListFunctorDecl *listfunctordecl_;

  Functor(const Functor &);
  Functor &operator=(const Functor &);
  Functor(LowerIdent p1, ListFunctorDecl *p2);
  ~Functor();
  virtual void accept(Visitor *v);
  virtual Functor *clone() const;
  void swap(Functor &);
};

class FunctorComponent : public FunctorDecl
{
public:
  FunctorSpec *functorspec_;

  FunctorComponent(const FunctorComponent &);
  FunctorComponent &operator=(const FunctorComponent &);
  FunctorComponent(FunctorSpec *p1);
  ~FunctorComponent();
  virtual void accept(Visitor *v);
  virtual FunctorComponent *clone() const;
  void swap(FunctorComponent &);
};

class Generic : public FunctorSpec
{
public:
  ListGenericParameter *listgenericparameter_;

  Generic(const Generic &);
  Generic &operator=(const Generic &);
  Generic(ListGenericParameter *p1);
  ~Generic();
  virtual void accept(Visitor *v);
  virtual Generic *clone() const;
  void swap(Generic &);
};

class Satisfies : public FunctorSpec
{
public:
  ListType *listtype_;

  Satisfies(const Satisfies &);
  Satisfies &operator=(const Satisfies &);
  Satisfies(ListType *p1);
  ~Satisfies();
  virtual void accept(Visitor *v);
  virtual Satisfies *clone() const;
  void swap(Satisfies &);
};

class Requires : public FunctorSpec
{
public:
  ListType *listtype_;

  Requires(const Requires &);
  Requires &operator=(const Requires &);
  Requires(ListType *p1);
  ~Requires();
  virtual void accept(Visitor *v);
  virtual Requires *clone() const;
  void swap(Requires &);
};

class Fn : public FunctorSpec
{
public:
  FnDecl *fndecl_;

  Fn(const Fn &);
  Fn &operator=(const Fn &);
  Fn(FnDecl *p1);
  ~Fn();
  virtual void accept(Visitor *v);
  virtual Fn *clone() const;
  void swap(Fn &);
};

class FnParams : public FnDecl
{
public:
  ListFormalArgument *listformalargument_;
  ListStatement *liststatement_;

  FnParams(const FnParams &);
  FnParams &operator=(const FnParams &);
  FnParams(ListFormalArgument *p1, ListStatement *p2);
  ~FnParams();
  virtual void accept(Visitor *v);
  virtual FnParams *clone() const;
  void swap(FnParams &);
};

class ValueParam : public FormalArgument
{
public:
  ParamIdent *paramident_;
  Type *type_;

  ValueParam(const ValueParam &);
  ValueParam &operator=(const ValueParam &);
  ValueParam(ParamIdent *p1, Type *p2);
  ~ValueParam();
  virtual void accept(Visitor *v);
  virtual ValueParam *clone() const;
  void swap(ValueParam &);
};

class GenericParam : public FormalArgument
{
public:
  ParamIdent *paramident_;
  ListFormalArgument *listformalargument_;
  Type *type_;

  GenericParam(const GenericParam &);
  GenericParam &operator=(const GenericParam &);
  GenericParam(ParamIdent *p1, ListFormalArgument *p2, Type *p3);
  ~GenericParam();
  virtual void accept(Visitor *v);
  virtual GenericParam *clone() const;
  void swap(GenericParam &);
};

class FnCallExpr : public InformalParam
{
public:
  Expression *expression_;

  FnCallExpr(const FnCallExpr &);
  FnCallExpr &operator=(const FnCallExpr &);
  FnCallExpr(Expression *p1);
  ~FnCallExpr();
  virtual void accept(Visitor *v);
  virtual FnCallExpr *clone() const;
  void swap(FnCallExpr &);
};

class ValueOrRef : public Expression
{
public:
  ParamIdent *paramident_;

  ValueOrRef(const ValueOrRef &);
  ValueOrRef &operator=(const ValueOrRef &);
  ValueOrRef(ParamIdent *p1);
  ~ValueOrRef();
  virtual void accept(Visitor *v);
  virtual ValueOrRef *clone() const;
  void swap(ValueOrRef &);
};

class IntLiteral : public Expression
{
public:
  Integer integer_;

  IntLiteral(const IntLiteral &);
  IntLiteral &operator=(const IntLiteral &);
  IntLiteral(Integer p1);
  ~IntLiteral();
  virtual void accept(Visitor *v);
  virtual IntLiteral *clone() const;
  void swap(IntLiteral &);
};

class RealLiteral : public Expression
{
public:
  Double double_;

  RealLiteral(const RealLiteral &);
  RealLiteral &operator=(const RealLiteral &);
  RealLiteral(Double p1);
  ~RealLiteral();
  virtual void accept(Visitor *v);
  virtual RealLiteral *clone() const;
  void swap(RealLiteral &);
};

class StringLiteral : public Expression
{
public:
  String string_;

  StringLiteral(const StringLiteral &);
  StringLiteral &operator=(const StringLiteral &);
  StringLiteral(String p1);
  ~StringLiteral();
  virtual void accept(Visitor *v);
  virtual StringLiteral *clone() const;
  void swap(StringLiteral &);
};

class CharLiteral : public Expression
{
public:
  Char char_;

  CharLiteral(const CharLiteral &);
  CharLiteral &operator=(const CharLiteral &);
  CharLiteral(Char p1);
  ~CharLiteral();
  virtual void accept(Visitor *v);
  virtual CharLiteral *clone() const;
  void swap(CharLiteral &);
};

class FnLiteral : public Expression
{
public:
  FnDecl *fndecl_;

  FnLiteral(const FnLiteral &);
  FnLiteral &operator=(const FnLiteral &);
  FnLiteral(FnDecl *p1);
  ~FnLiteral();
  virtual void accept(Visitor *v);
  virtual FnLiteral *clone() const;
  void swap(FnLiteral &);
};

class DotOperator : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  DotOperator(const DotOperator &);
  DotOperator &operator=(const DotOperator &);
  DotOperator(Expression *p1, Expression *p2);
  ~DotOperator();
  virtual void accept(Visitor *v);
  virtual DotOperator *clone() const;
  void swap(DotOperator &);
};

class PipeOperator : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  PipeOperator(const PipeOperator &);
  PipeOperator &operator=(const PipeOperator &);
  PipeOperator(Expression *p1, Expression *p2);
  ~PipeOperator();
  virtual void accept(Visitor *v);
  virtual PipeOperator *clone() const;
  void swap(PipeOperator &);
};

class CallOperator : public Expression
{
public:
  Expression *expression_;
  ListInformalParam *listinformalparam_;

  CallOperator(const CallOperator &);
  CallOperator &operator=(const CallOperator &);
  CallOperator(Expression *p1, ListInformalParam *p2);
  ~CallOperator();
  virtual void accept(Visitor *v);
  virtual CallOperator *clone() const;
  void swap(CallOperator &);
};

class LeftShiftOperator : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  LeftShiftOperator(const LeftShiftOperator &);
  LeftShiftOperator &operator=(const LeftShiftOperator &);
  LeftShiftOperator(Expression *p1, Expression *p2);
  ~LeftShiftOperator();
  virtual void accept(Visitor *v);
  virtual LeftShiftOperator *clone() const;
  void swap(LeftShiftOperator &);
};

class RightShiftOperator : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  RightShiftOperator(const RightShiftOperator &);
  RightShiftOperator &operator=(const RightShiftOperator &);
  RightShiftOperator(Expression *p1, Expression *p2);
  ~RightShiftOperator();
  virtual void accept(Visitor *v);
  virtual RightShiftOperator *clone() const;
  void swap(RightShiftOperator &);
};

class MultOperator : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  MultOperator(const MultOperator &);
  MultOperator &operator=(const MultOperator &);
  MultOperator(Expression *p1, Expression *p2);
  ~MultOperator();
  virtual void accept(Visitor *v);
  virtual MultOperator *clone() const;
  void swap(MultOperator &);
};

class DivisionOperator : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  DivisionOperator(const DivisionOperator &);
  DivisionOperator &operator=(const DivisionOperator &);
  DivisionOperator(Expression *p1, Expression *p2);
  ~DivisionOperator();
  virtual void accept(Visitor *v);
  virtual DivisionOperator *clone() const;
  void swap(DivisionOperator &);
};

class PlusOperator : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  PlusOperator(const PlusOperator &);
  PlusOperator &operator=(const PlusOperator &);
  PlusOperator(Expression *p1, Expression *p2);
  ~PlusOperator();
  virtual void accept(Visitor *v);
  virtual PlusOperator *clone() const;
  void swap(PlusOperator &);
};

class MinusOperator : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  MinusOperator(const MinusOperator &);
  MinusOperator &operator=(const MinusOperator &);
  MinusOperator(Expression *p1, Expression *p2);
  ~MinusOperator();
  virtual void accept(Visitor *v);
  virtual MinusOperator *clone() const;
  void swap(MinusOperator &);
};

class Declaration : public Statement
{
public:
  FormalArgument *formalargument_;

  Declaration(const Declaration &);
  Declaration &operator=(const Declaration &);
  Declaration(FormalArgument *p1);
  ~Declaration();
  virtual void accept(Visitor *v);
  virtual Declaration *clone() const;
  void swap(Declaration &);
};

class Expr : public Statement
{
public:
  Expression *expression_;

  Expr(const Expr &);
  Expr &operator=(const Expr &);
  Expr(Expression *p1);
  ~Expr();
  virtual void accept(Visitor *v);
  virtual Expr *clone() const;
  void swap(Expr &);
};

class Assignment : public Statement
{
public:
  Expression *expression_1;
  Expression *expression_2;

  Assignment(const Assignment &);
  Assignment &operator=(const Assignment &);
  Assignment(Expression *p1, Expression *p2);
  ~Assignment();
  virtual void accept(Visitor *v);
  virtual Assignment *clone() const;
  void swap(Assignment &);
};



class ListTopLevelBlock : public Visitable, public std::vector<TopLevelBlock*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListTopLevelBlock *clone() const;
};

class ListBlock : public Visitable, public std::vector<Block*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListBlock *clone() const;
};

class ListNamespaceIdent : public Visitable, public std::vector<NamespaceIdent*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListNamespaceIdent *clone() const;
};

class ListGenericParameter : public Visitable, public std::vector<GenericParameter>
{
public:
  virtual void accept(Visitor *v);
  virtual ListGenericParameter *clone() const;
};

class ListType : public Visitable, public std::vector<Type*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListType *clone() const;
};

class ListFunctorDecl : public Visitable, public std::vector<FunctorDecl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFunctorDecl *clone() const;
};

class ListFormalArgument : public Visitable, public std::vector<FormalArgument*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFormalArgument *clone() const;
};

class ListInformalParam : public Visitable, public std::vector<InformalParam*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListInformalParam *clone() const;
};

class ListStatement : public Visitable, public std::vector<Statement*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStatement *clone() const;
};



#endif
